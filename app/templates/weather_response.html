{% extends "base.html" %}

{% block content %}
<div id="weather-results" class="results-container">
    <!-- Weather Summary Card -->
    <div class="card summary-card">
        <div class="weather-info" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
            <div class="weather-stat">
                <span class="stat-label">Current</span>
                <span class="stat-value" style="color: #43a047; font-weight: bold;">{{ temp|default('-') if temp is not none else '-' }}¬∞F</span>
            </div>
            <div class="weather-stat">
                <span class="stat-label">Feels Like</span>
                <span class="stat-value" style="color: #1976d2; font-weight: bold;">{{ feels_like|default('-') if feels_like is not none else '-' }}¬∞F</span>
            </div>
            <div class="weather-stat">
                <span class="stat-label">High</span>
                <span class="stat-value" style="color: #e53935; font-weight: bold;">{{ temp_max|default('-') if temp_max is not none else '-' }}¬∞F</span>
            </div>
            <div class="weather-stat">
                <span class="stat-label">Low</span>
                <span class="stat-value" style="color: #f06292; font-weight: bold;">{{ temp_min|default('-') if temp_min is not none else '-' }}¬∞F</span>
            </div>
            <div class="weather-stat">
                <span class="stat-label">Wind</span>
                <span class="stat-value">
                  {{ wind_speed|default('-') if wind_speed is not none else '-' }} MPH
                </span>
            </div>
            <div class="weather-stat">
                <span class="stat-label">Conditions</span>
                <span class="stat-value">{{ conditions }}</span>
            </div>
        </div>
        <hr style="margin: 1rem 0;">
        <div class="weather-summary forecast-sections">
            {{ summary|safe }}
        </div>
        <style>
            .forecast-sections h3 {
                margin-top: 1rem;
                margin-bottom: 0.5rem;
                color: var(--accent);
                font-size: 1.2rem;
                font-weight: 600;
            }
            .forecast-sections p {
                margin-bottom: 1rem;
                line-height: 1.5;
                font-size: 1.1rem;
            }
        </style>
    </div>

    <!-- Weather Warning Card for Wet Conditions -->
    {% if conditions.lower() in ['rain', 'snow', 'drizzle', 'thunderstorm', 'sleet'] %}
    <div class="card warning-card">
        <h2>üåßÔ∏è Weather Warning</h2>
        <div class="warning-message">
            <strong>Wet conditions detected:</strong> {{ conditions }}
            <p>Remember to bring appropriate rain gear and watch your step - surfaces may be slippery!</p>
        </div>
    </div>
    {% endif %}

    <!-- Safety Alerts Card -->
    {% if safety_recommendations %}
    <div class="card safety-card">
        <h2>‚ö†Ô∏è Safety Notes</h2>
        <div class="safety-container">
            {% for rec in safety_recommendations %}
            <div class="recommendation safety-alert">
                {{ rec }}
            </div>
            {% endfor %}
        </div>
    </div>
    {% endif %}

    <!-- Clothing Recommendations Card -->
    <div class="card clothing-card">
        <h2>üëï What to Wear</h2>
        <div class="layers-container">
            {% for recommendation in recommendations %}
            <div class="layer-section">
                <div class="recommendation">{{ recommendation }}</div>
            </div>
            {% endfor %}
        </div>
    </div>

    <style>
        .results-container {
            display: grid;
            gap: 1.5rem;
            max-width: 800px;
            margin: 0 auto;
        }

        .card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
        }

        .summary-card .weather-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: var(--bg-primary);
            border-radius: 12px;
        }

        .weather-stat {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .weather-summary {
            font-size: 1.2rem;
            line-height: 1.6;
            color: var(--text-primary);
            padding: 1rem;
            background: var(--bg-primary);
            border-radius: 12px;
            margin-top: 1rem;
        }

        .safety-card {
            border: 2px solid var(--error);
            background: var(--bg-primary);
        }

        .safety-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .safety-alert {
            color: var(--error);
            font-weight: 500;
            padding: 0.75rem;
            background: rgba(var(--error-rgb), 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .clothing-card {
            background: var(--bg-primary);
        }

        .layers-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.25rem;
            padding: 0.5rem;
        }

        .layer-section {
            position: relative;
            padding: 1.25rem;
            background: var(--bg-secondary);
            border-radius: 16px;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            overflow: hidden;
        }

        .layer-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .layer-section:hover {
            transform: translateY(-2px);
            border-color: var(--accent);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .layer-section:hover::before {
            opacity: 1;
        }

        .recommendation {
            color: var(--text-primary);
            font-size: 1.1rem;
            line-height: 1.6;
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .recommendation::first-letter {
            font-size: 1.2em;
            color: var(--accent);
        }

        h2 {
            color: var(--accent);
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Practical Weather Essentials styles */
        .practical-weather-card {
            padding: 1.5rem;
            background: var(--bg-primary);
        }

        .practical-weather-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.25rem;
            padding: 0.5rem;
        }

        .practical-stat {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1.25rem;
            background: var(--bg-secondary);
            border-radius: 16px;
            border-left: 4px solid var(--accent);
            transition: all 0.3s ease;
        }

        .practical-stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .practical-icon {
            font-size: 2rem;
            line-height: 1;
        }

        .practical-info {
            flex: 1;
        }

        .practical-title {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
        }

        .practical-value {
            font-size: 1.1rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        /* Status indicators */
        .practical-stat.alert {
            border-color: #ff5252;
        }

        .practical-stat.good {
            border-color: #4caf50;
        }

        .practical-stat.temperature .practical-value {
            font-weight: 600;
            color: var(--accent);
        }
    </style>

    <!-- Temperature Graph Card -->
    <div class="card temperature-graph-card">
        <h2>üìä Today's Temperature Trend</h2>
        <div class="simple-chart-container">
            <div class="chart-area">
                <!-- Y-axis labels -->
                <div class="y-axis">
                    <div class="y-label" data-temp="high">--¬∞F</div>
                    <div class="y-label" data-temp="mid">--¬∞F</div>
                    <div class="y-label" data-temp="low">--¬∞F</div>
                </div>
                
                <!-- Chart plotting area -->
                <div class="plot-area" id="plotArea">
                    <!-- Data points will be inserted here by JavaScript -->
                </div>
                
                <!-- X-axis labels -->
                <div class="x-axis" id="xAxis">
                    <!-- Time labels will be inserted here by JavaScript -->
                </div>
            </div>
            
            <!-- Legend -->
            <div class="chart-legend">
                <div class="legend-item">
                    <span class="legend-color actual-temp"></span>
                    <span>Actual Temperature</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color feels-like-temp"></span>
                    <span>Feels Like</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color current-time"></span>
                    <span>Current Time</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Parent-Focused Weather Card -->
    <div class="card practical-weather-card">
        <h2>üìù Today's Weather Essentials</h2>
        <div class="practical-weather-container">
            <!-- Temperature Summary -->
            <div class="practical-stat temperature">
                <div class="practical-icon">üå°Ô∏è</div>
                <div class="practical-info">
                    <div class="practical-title">Temperature</div>
                    <div class="practical-value">{{ temp|default('-') if temp is not none else '-' }}¬∞F now, ranging from {{ temp_min|default('-') }}¬∞F to {{ temp_max|default('-') }}¬∞F</div>
                </div>
            </div>
            
            <!-- Rain/Umbrella -->
            {% set needs_umbrella = conditions.lower() in ['rain', 'drizzle', 'thunderstorm'] or pop|default(0) >= 30 %}
            <div class="practical-stat umbrella {% if needs_umbrella %}alert{% endif %}">
                <div class="practical-icon">{{ '‚òî' if needs_umbrella else 'üåÇ' }}</div>
                <div class="practical-info">
                    <div class="practical-title">Umbrella</div>
                    <div class="practical-value">
                        {% if needs_umbrella %}
                            Yes, bring one today ({{ pop|default(0) }}% chance of rain)
                        {% else %}
                            Not needed today ({{ pop|default(0) }}% chance of rain)
                        {% endif %}
                    </div>
                </div>
            </div>
            
            <!-- Footwear -->
            {% set wet_conditions = conditions.lower() in ['rain', 'snow', 'drizzle', 'thunderstorm', 'sleet'] %}
            {% set hot_conditions = temp|default(0) > 80 %}
            <div class="practical-stat footwear">
                <div class="practical-icon">üëû</div>
                <div class="practical-info">
                    <div class="practical-title">Footwear</div>
                    <div class="practical-value">
                        {% if wet_conditions %}
                            Waterproof shoes recommended
                        {% elif hot_conditions %}
                            Sandals should be fine today
                        {% else %}
                            Regular shoes appropriate
                        {% endif %}
                    </div>
                </div>
            </div>
            
            <!-- Sun Protection -->
            {% set sunny = conditions.lower() in ['clear', 'sunny'] or 'clear' in conditions.lower() %}
            <div class="practical-stat sun {% if sunny %}alert{% endif %}">
                <div class="practical-icon">‚òÄÔ∏è</div>
                <div class="practical-info">
                    <div class="practical-title">Sun Protection</div>
                    <div class="practical-value">
                        {% if sunny %}
                            Sunscreen and hat recommended
                        {% else %}
                            Minimal sun protection needed
                        {% endif %}
                    </div>
                </div>
            </div>
            
            <!-- Wind -->
            {% set windy = wind_speed|default(0) > 15 %}
            <div class="practical-stat wind {% if windy %}alert{% endif %}">
                <div class="practical-icon">üí®</div>
                <div class="practical-info">
                    <div class="practical-title">Wind</div>
                    <div class="practical-value">
                        {{ wind_speed|default('-') }} MPH - {{ "Windy, secure loose items" if windy else "Light breeze" }}
                    </div>
                </div>
            </div>
            
            <!-- Outdoor Activity -->
            {% set good_for_outdoors = not wet_conditions and temp|default(0) > 50 and temp|default(0) < 95 and wind_speed|default(0) < 20 %}
            <div class="practical-stat outdoor {% if good_for_outdoors %}good{% endif %}">
                <div class="practical-icon">üèûÔ∏è</div>
                <div class="practical-info">
                    <div class="practical-title">Outdoor Activities</div>
                    <div class="practical-value">
                        {% if good_for_outdoors %}
                            Great day for outdoor play
                        {% else %}
                            Consider indoor alternatives
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Store forecast data with comprehensive debugging -->
    <input type="hidden" id="forecast-data" value='{{ forecast|tojson|safe }}'>
    <input type="hidden" id="current-temp" value="{{ temp if temp is not none else '' }}">
    <input type="hidden" id="current-feels-like" value="{{ feels_like if feels_like is not none else '' }}">
    
    <!-- Optional: D3 via CDN (not required). We render with plain SVG so the chart works offline. -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7" defer></script>
    <script>
    function initTempChart() {
        console.log('=== TEMPERATURE CHART DEBUG START ===');
        
        // Get forecast data from hidden input
        const forecastDataElement = document.getElementById('forecast-data');
        
        if (!forecastDataElement) {
            console.error('‚ùå No forecast data element found');
            showChartError('Chart data element not found');
            return;
        }
        
        console.log('‚úÖ Found forecast data element');
        
        // Debug: Show raw data
        const rawData = forecastDataElement.value;
        console.log('üìä Raw forecast data:', rawData.substring(0, 200) + (rawData.length > 200 ? '...' : ''));
        
        let forecastData;
        try {
            forecastData = JSON.parse(rawData);
            console.log('‚úÖ Successfully parsed JSON data');
            console.log('üìà Forecast data length:', forecastData ? forecastData.length : 'null');
        } catch (e) {
            console.error('‚ùå Error parsing forecast data:', e);
            console.error('üîç Raw data that failed to parse:', rawData);
            showChartError('Failed to parse weather data');
            return;
        }
        
        if (!forecastData) {
            console.error('‚ùå Forecast data is null or undefined');
            showChartError('No weather data available');
            return;
        }
        
        if (!Array.isArray(forecastData)) {
            console.error('‚ùå Forecast data is not an array:', typeof forecastData);
            showChartError('Invalid weather data format');
            return;
        }
        
        if (forecastData.length === 0) {
            console.error('‚ùå Forecast data array is empty');
            showChartError('No weather data points available');
            return;
        }
        
        console.log('‚úÖ Forecast data validation passed');
        console.log('üìä Sample data point:', forecastData[0]);
        
        // Current time
        const currentTime = Date.now();
        console.log('üïê Current time (ms):', currentTime);
        console.log('üïê Current time (readable):', new Date(currentTime).toLocaleString());
        
        // Show all data points for debugging
        console.log('üìã All forecast data points:');
        forecastData.forEach((point, index) => {
            const pointTime = new Date(point.time);
            console.log(`  ${index}: ${pointTime.toLocaleString()} - ${point.temp}¬∞F (feels ${point.feels_like}¬∞F)`);
        });
        
        // More flexible time filtering - include yesterday evening through tomorrow morning
        const now = new Date(currentTime);
        const yesterday = new Date(now);
        yesterday.setDate(yesterday.getDate() - 1);
        yesterday.setHours(18, 0, 0, 0); // 6 PM yesterday
        
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(12, 0, 0, 0); // 12 PM tomorrow
        
        console.log('üîç Time filter range:');
        console.log('  From:', yesterday.toLocaleString());
        console.log('  To:', tomorrow.toLocaleString());
        
        const relevantData = forecastData
            .filter(point => {
                const pointTime = new Date(point.time);
                const isInRange = pointTime >= yesterday && pointTime <= tomorrow;
                if (!isInRange) {
                    console.log(`  ‚è≠Ô∏è Skipping ${pointTime.toLocaleString()} (outside range)`);
                }
                return isInRange;
            })
            .sort((a, b) => a.time - b.time);
        
        console.log(`‚úÖ Filtered to ${relevantData.length} relevant data points`);
        
        if (relevantData.length === 0) {
            console.error('‚ùå No data points in time range');
            showChartError('No weather data for the current time period');
            return;
        }
        
        // Ensure we have valid temperature data
        const validData = relevantData.filter(point => {
            const hasValidTemp = typeof point.temp === 'number' && !isNaN(point.temp);
            const hasValidFeels = typeof point.feels_like === 'number' && !isNaN(point.feels_like);
            const hasValidTime = typeof point.time === 'number' && point.time > 0;
            
            if (!hasValidTemp || !hasValidFeels || !hasValidTime) {
                console.warn('‚ö†Ô∏è Invalid data point:', point);
                return false;
            }
            return true;
        });
        
        console.log(`‚úÖ ${validData.length} valid data points after validation`);
        
        if (validData.length === 0) {
            console.error('‚ùå No valid data points found');
            console.log('üîÑ Attempting to generate fallback data from current weather...');
            
            // Try to generate fallback data using current weather
            const currentTempElement = document.getElementById('current-temp');
            const currentFeelsLikeElement = document.getElementById('current-feels-like');
            const currentTemp = currentTempElement && currentTempElement.value ? parseFloat(currentTempElement.value) : null;
            const currentFeelsLike = currentFeelsLikeElement && currentFeelsLikeElement.value ? parseFloat(currentFeelsLikeElement.value) : null;
            
            if (currentTemp !== null && currentFeelsLike !== null) {
                console.log(`üå°Ô∏è Using current weather: ${currentTemp}¬∞F (feels like ${currentFeelsLike}¬∞F)`);
                
                // Generate a simple day-long forecast based on current conditions
                let fallbackData = [];
                const baseTime = new Date();
                baseTime.setHours(6, 0, 0, 0); // Start at 6 AM
                
                // Create hourly points from 6 AM to 10 PM
                for (let hour = 6; hour <= 22; hour++) {
                    const pointTime = new Date(baseTime);
                    pointTime.setHours(hour);
                    
                    // Create realistic temperature variation throughout the day
                    let tempVariation = 0;
                    if (hour >= 6 && hour <= 12) {
                        // Morning: gradually warming up
                        tempVariation = -8 + (hour - 6) * 2; // -8¬∞F at 6 AM to +4¬∞F at noon
                    } else if (hour >= 12 && hour <= 16) {
                        // Afternoon: peak heat
                        tempVariation = 4 - (hour - 12) * 0.5; // +4¬∞F at noon to +2¬∞F at 4 PM
                    } else {
                        // Evening: cooling down
                        tempVariation = 2 - (hour - 16) * 1.5; // +2¬∞F at 4 PM to -7¬∞F at 10 PM
                    }
                    
                    const estimatedTemp = currentTemp + tempVariation;
                    const estimatedFeelsLike = currentFeelsLike + tempVariation * 1.1;
                    
                    fallbackData.push({
                        time: pointTime.getTime(),
                        temp: Math.round(estimatedTemp * 10) / 10,
                        feels_like: Math.round(estimatedFeelsLike * 10) / 10,
                        description: 'Estimated'
                    });
                }
                
                console.log(`‚úÖ Generated ${fallbackData.length} fallback data points`);
                validData = fallbackData;
                
                // Recalculate current time index
                currentTimeIndex = -1;
                let newMinTimeDiff = Infinity;
                validData.forEach((point, index) => {
                    const timeDiff = Math.abs(point.time - currentTime);
                    if (timeDiff < newMinTimeDiff) {
                        newMinTimeDiff = timeDiff;
                        currentTimeIndex = index;
                    }
                });
                minTimeDiff = newMinTimeDiff;
            } else {
                console.error('‚ùå No current weather data available for fallback');
                showChartError('No weather data available');
                return;
            }
        }
        
        // Prefer showing just today's data in America/New_York (5 AM ‚Äì 11 PM).
        (function scopeTodayFilter(){
            try {
                const tz = 'America/New_York';
                const todayStrET = new Date().toLocaleDateString('en-US', { timeZone: tz });
                function etHour(ms){
                    return Number(new Date(ms).toLocaleString('en-US', { hour: 'numeric', hour12: false, timeZone: tz }));
                }
                function isTodayET(ms){
                    return new Date(ms).toLocaleDateString('en-US', { timeZone: tz }) === todayStrET;
                }

                let todayData = validData.filter(p => isTodayET(p.time) && etHour(p.time) >= 5 && etHour(p.time) <= 23)
                                          .sort((a,b) => a.time - b.time);
                console.log(`üìÖ Today ET points (5‚Äì23h): ${todayData.length}`);
                validData = todayData;

                // If too sparse, synthesize a realistic diurnal curve and blend in known points
                if (!Array.isArray(validData) || validData.length < 6) {
                    const currentTempEl = document.getElementById('current-temp');
                    const baseNow = Number(currentTempEl && currentTempEl.value ? currentTempEl.value : 72);
                    const ymd = new Date().toLocaleDateString('en-CA', { timeZone: tz }); // YYYY-MM-DD

                    // Estimate day min/max from any available points; fall back around the current temp
                    const temps = (validData||[]).map(p => Number(p.temp)).filter(v => Number.isFinite(v));
                    const tMinEst = temps.length ? Math.min(...temps) : baseNow - 6;
                    const tMaxEst = temps.length ? Math.max(...temps) : baseNow + 6;
                    const dayMin = Math.min(tMinEst, baseNow - 4);
                    const dayMax = Math.max(tMaxEst, baseNow + 4);

                    const hourly = [];
                    for (let h = 5; h <= 23; h++) {
                        const tLocal = new Date(`${ymd}T${String(h).padStart(2,'0')}:00:00`);
                        // Rise 6->15 using eased sine, fall 15->23 toward evening baseline
                        let temp;
                        if (h <= 15) {
                            const prog = Math.max(0, Math.min(1, (h - 6) / 9));
                            temp = dayMin + (dayMax - dayMin) * Math.sin((Math.PI/2) * prog);
                        } else {
                            const eveningBase = dayMin + 2;
                            const prog = Math.max(0, Math.min(1, (h - 15) / 8));
                            temp = dayMax - (dayMax - eveningBase) * Math.sin((Math.PI/2) * prog);
                        }
                        // Feels-like is slightly warmer midday, slightly cooler night
                        const feelsOffset = (h >= 12 && h <= 18) ? 1.2 : 0.4;
                        const fl = temp + feelsOffset;
                        hourly.push({ time: tLocal.getTime(), temp, feels_like: fl, description: '' });
                    }
                    // Blend in any known points at matching ET hours
                    validData.forEach(p => {
                        const h = etHour(p.time);
                        const idx = hourly.findIndex(x => etHour(x.time) === h);
                        if (idx !== -1) hourly[idx] = { ...hourly[idx], temp: p.temp, feels_like: p.feels_like, description: p.description };
                    });
                    console.log(`üß™ Synthesized diurnal curve with blending.`);
                    validData = hourly;
                } else {
                    // Interpolate to hourly grid for smooth spacing if points are 3-hourly
                    const grid = [];
                    for (let h = 5; h <= 23; h++) {
                        const left = [...validData].reverse().find(p => etHour(p.time) <= h);
                        const right = validData.find(p => etHour(p.time) >= h);
                        if (!left || !right) continue;
                        const lh = etHour(left.time);
                        const rh = etHour(right.time);
                        const span = Math.max(1, rh - lh);
                        const r = Math.min(1, Math.max(0, (h - lh) / span));
                        const t = left.time + r * (right.time - left.time);
                        const temp = left.temp + r * (right.temp - left.temp);
                        const fl = left.feels_like + r * (right.feels_like - left.feels_like);
                        grid.push({ time: t, temp, feels_like: fl, description: right.description || left.description || '' });
                    }
                    if (grid.length >= 6) {
                        console.log(`üïê Interpolated to hourly grid: ${grid.length}`);
                        validData = grid;
                    }
                }

                // Final normalization: sort and de-duplicate by ET hour to guarantee sequential hours 5..23
                const hourETKey = ms => Number(new Date(ms).toLocaleString('en-US', { hour: 'numeric', hour12: false, timeZone: tz }));
                validData = (validData || []).slice().sort((a,b) => a.time - b.time);
                const seenHours = new Set();
                validData = validData.filter(p => {
                    const h = hourETKey(p.time);
                    if (h < 5 || h > 23) return false;
                    if (seenHours.has(h)) return false;
                    seenHours.add(h);
                    return true;
                });
                console.log(`‚úÖ Normalized hours kept: ${Array.from(seenHours).join(', ')}`);
            } catch (e) {
                console.warn('Failed to apply today-only filter:', e);
            }
        })();

        // Find temperature range for scaling
        const allTemps = [];
        validData.forEach(point => {
            allTemps.push(point.temp, point.feels_like);
        });
        
        const minTemp = Math.min(...allTemps);
        const maxTemp = Math.max(...allTemps);
        const tempRange = maxTemp - minTemp;
        const padding = Math.max(tempRange * 0.15, 5); // At least 5¬∞F padding
        const chartMin = minTemp - padding;
        const chartMax = maxTemp + padding;
        
        console.log('üìä Temperature range:');
        console.log(`  Min: ${minTemp}¬∞F, Max: ${maxTemp}¬∞F`);
        console.log(`  Chart range: ${chartMin.toFixed(1)}¬∞F to ${chartMax.toFixed(1)}¬∞F`);
        
        // Update Y-axis labels
        document.querySelector('[data-temp="high"]').textContent = Math.round(chartMax) + '¬∞F';
        document.querySelector('[data-temp="mid"]').textContent = Math.round((chartMax + chartMin) / 2) + '¬∞F';
        document.querySelector('[data-temp="low"]').textContent = Math.round(chartMin) + '¬∞F';

        // Use ET hour (5‚Äì23) for X positioning to avoid timezone drift and day spillover
        const tzET = 'America/New_York';
        const minHourET = 5;
        const maxHourET = 23;
        function hourET(ms){
            return Number(new Date(ms).toLocaleString('en-US', { hour: 'numeric', hour12: false, timeZone: tzET }));
        }

        // Plain SVG renderer (no external dependency): connects dots and draws a vertical dotted "now" line
        function renderWithSVG(data, chartMin, chartMax) {
            const plotArea = document.getElementById('plotArea');
            let rect = plotArea.getBoundingClientRect();
            // If layout not ready (e.g., HTMX swap), wait a tick and retry
            if (!rect || rect.width < 10 || rect.height < 10) {
                console.warn('Plot area not measured yet, deferring render...');
                return setTimeout(() => renderWithSVG(data, chartMin, chartMax), 50);
            }
            plotArea.innerHTML = '';

            const svgNS = 'http://www.w3.org/2000/svg';
            const svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
            svg.setAttribute('preserveAspectRatio', 'none');
            plotArea.appendChild(svg);

            const x = h => (Math.min(maxHourET, Math.max(minHourET, h)) - minHourET) / (maxHourET - minHourET) * rect.width;
            const y = v => (1 - (v - chartMin) / (chartMax - chartMin)) * rect.height;

            // Sort data by ET hour for continuous curve rendering
            const sorted = data.slice().sort((a,b) => hourET(a.time) - hourET(b.time));

            // Advanced smooth curve generation using Catmull-Rom spline interpolation
            const generateSmoothCurve = (seg, valueSelector, tension = 0.4, smoothing = 0.3) => {
                if (!seg || seg.length < 2) return '';
                
                // Convert data points to coordinates
                const points = seg.map(d => ({
                    x: x(hourET(d.time)),
                    y: y(valueSelector(d))
                }));
                
                if (points.length === 2) {
                    return `M ${points[0].x} ${points[0].y} L ${points[1].x} ${points[1].y}`;
                }

                // Calculate control points using Catmull-Rom spline approach
                const getControlPoints = (p0, p1, p2, p3) => {
                    const d01 = Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2));
                    const d12 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    const d23 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));

                    const alpha = 0.5; // Catmull-Rom alpha parameter
                    
                    const t01 = Math.pow(d01, alpha);
                    const t12 = Math.pow(d12, alpha);
                    const t23 = Math.pow(d23, alpha);

                    const m1x = (1 - tension) * (p2.x - p0.x) / (t01 + t12);
                    const m1y = (1 - tension) * (p2.y - p0.y) / (t01 + t12);
                    const m2x = (1 - tension) * (p3.x - p1.x) / (t12 + t23);
                    const m2y = (1 - tension) * (p3.y - p1.y) / (t12 + t23);

                    const cp1x = p1.x + smoothing * t12 * m1x;
                    const cp1y = p1.y + smoothing * t12 * m1y;
                    const cp2x = p2.x - smoothing * t12 * m2x;
                    const cp2y = p2.y - smoothing * t12 * m2y;

                    return { cp1: { x: cp1x, y: cp1y }, cp2: { x: cp2x, y: cp2y } };
                };

                let path = `M ${points[0].x} ${points[0].y}`;

                for (let i = 0; i < points.length - 1; i++) {
                    const p0 = points[Math.max(0, i - 1)];
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const p3 = points[Math.min(points.length - 1, i + 2)];

                    const { cp1, cp2 } = getControlPoints(p0, p1, p2, p3);
                    path += ` C ${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${p2.x} ${p2.y}`;
                }

                return path;
            };

            // Add gradient definitions for enhanced visual effects
            const defs = document.createElementNS(svgNS, 'defs');
            
            // Actual temperature gradient
            const actualGradient = document.createElementNS(svgNS, 'linearGradient');
            actualGradient.setAttribute('id', 'actualTempGradient');
            actualGradient.setAttribute('x1', '0%');
            actualGradient.setAttribute('y1', '0%');
            actualGradient.setAttribute('x2', '100%');
            actualGradient.setAttribute('y2', '0%');
            
            const actualStop1 = document.createElementNS(svgNS, 'stop');
            actualStop1.setAttribute('offset', '0%');
            actualStop1.setAttribute('stop-color', '#43a047');
            
            const actualStop2 = document.createElementNS(svgNS, 'stop');
            actualStop2.setAttribute('offset', '100%');
            actualStop2.setAttribute('stop-color', '#66bb6a');
            
            actualGradient.appendChild(actualStop1);
            actualGradient.appendChild(actualStop2);
            defs.appendChild(actualGradient);

            // Feels like gradient
            const feelsGradient = document.createElementNS(svgNS, 'linearGradient');
            feelsGradient.setAttribute('id', 'feelsLikeGradient');
            feelsGradient.setAttribute('x1', '0%');
            feelsGradient.setAttribute('y1', '0%');
            feelsGradient.setAttribute('x2', '100%');
            feelsGradient.setAttribute('y2', '0%');
            
            const feelsStop1 = document.createElementNS(svgNS, 'stop');
            feelsStop1.setAttribute('offset', '0%');
            feelsStop1.setAttribute('stop-color', '#1976d2');
            
            const feelsStop2 = document.createElementNS(svgNS, 'stop');
            feelsStop2.setAttribute('offset', '100%');
            feelsStop2.setAttribute('stop-color', '#42a5f5');
            
            feelsGradient.appendChild(feelsStop1);
            feelsGradient.appendChild(feelsStop2);
            defs.appendChild(feelsGradient);

            svg.appendChild(defs);

            // Render single continuous smooth curve for actual temperature
            const actualPathData = generateSmoothCurve(sorted, d => d.temp);
            if (actualPathData) {
                const actualPath = document.createElementNS(svgNS, 'path');
                actualPath.setAttribute('d', actualPathData);
                actualPath.setAttribute('fill', 'none');
                actualPath.setAttribute('stroke', 'url(#actualTempGradient)');
                actualPath.setAttribute('stroke-width', '4');
                actualPath.setAttribute('stroke-linecap', 'round');
                actualPath.setAttribute('stroke-linejoin', 'round');
                actualPath.setAttribute('filter', 'drop-shadow(0 2px 4px rgba(67, 160, 71, 0.3))');
                svg.appendChild(actualPath);
            }

            // Render single continuous smooth curve for feels-like temperature
            const feelsPathData = generateSmoothCurve(sorted, d => d.feels_like);
            if (feelsPathData) {
                const feelsPath = document.createElementNS(svgNS, 'path');
                feelsPath.setAttribute('d', feelsPathData);
                feelsPath.setAttribute('fill', 'none');
                feelsPath.setAttribute('stroke', 'url(#feelsLikeGradient)');
                feelsPath.setAttribute('stroke-width', '3');
                feelsPath.setAttribute('stroke-dasharray', '10,5');
                feelsPath.setAttribute('stroke-linecap', 'round');
                feelsPath.setAttribute('stroke-linejoin', 'round');
                feelsPath.setAttribute('filter', 'drop-shadow(0 2px 4px rgba(25, 118, 210, 0.3))');
                svg.appendChild(feelsPath);
            }

            // Enhanced data points with glow effects for smooth appearance
            data.forEach(d => {
                const hour = hourET(d.time);
                const px = x(hour);
                
                // Actual temperature point with subtle glow
                const c1Glow = document.createElementNS(svgNS, 'circle');
                c1Glow.setAttribute('cx', px);
                c1Glow.setAttribute('cy', y(d.temp));
                c1Glow.setAttribute('r', '8');
                c1Glow.setAttribute('fill', '#43a047');
                c1Glow.setAttribute('opacity', '0.2');
                svg.appendChild(c1Glow);
                
                const c1 = document.createElementNS(svgNS, 'circle');
                c1.setAttribute('cx', px);
                c1.setAttribute('cy', y(d.temp));
                c1.setAttribute('r', '5');
                c1.setAttribute('fill', '#43a047');
                c1.setAttribute('stroke', '#ffffff');
                c1.setAttribute('stroke-width', '2');
                c1.style.cursor = 'pointer';
                const t1 = document.createElementNS(svgNS, 'title');
                t1.textContent = `${d.temp}¬∞F at ${new Date(d.time).toLocaleTimeString('en-US',{hour:'numeric',hour12:true})}`;
                c1.appendChild(t1);
                svg.appendChild(c1);

                // Feels-like temperature point with subtle glow
                const c2Glow = document.createElementNS(svgNS, 'circle');
                c2Glow.setAttribute('cx', px);
                c2Glow.setAttribute('cy', y(d.feels_like));
                c2Glow.setAttribute('r', '7');
                c2Glow.setAttribute('fill', '#1976d2');
                c2Glow.setAttribute('opacity', '0.2');
                svg.appendChild(c2Glow);
                
                const c2 = document.createElementNS(svgNS, 'circle');
                c2.setAttribute('cx', px);
                c2.setAttribute('cy', y(d.feels_like));
                c2.setAttribute('r', '4');
                c2.setAttribute('fill', '#1976d2');
                c2.setAttribute('stroke', '#ffffff');
                c2.setAttribute('stroke-width', '2');
                c2.style.cursor = 'pointer';
                const t2 = document.createElementNS(svgNS, 'title');
                t2.textContent = `Feels like ${d.feels_like}¬∞F at ${new Date(d.time).toLocaleTimeString('en-US',{hour:'numeric',hour12:true})}`;
                c2.appendChild(t2);
                svg.appendChild(c2);
            });

            // Add gradient for current time line to existing defs
            const timeGradient = document.createElementNS(svgNS, 'linearGradient');
            timeGradient.setAttribute('id', 'timeLineGradient');
            timeGradient.setAttribute('x1', '0%');
            timeGradient.setAttribute('y1', '0%');
            timeGradient.setAttribute('x2', '0%');
            timeGradient.setAttribute('y2', '100%');
            
            const stop1 = document.createElementNS(svgNS, 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', '#ff6b6b');
            stop1.setAttribute('stop-opacity', '0.8');
            
            const stop2 = document.createElementNS(svgNS, 'stop');
            stop2.setAttribute('offset', '50%');
            stop2.setAttribute('stop-color', '#ff6b6b');
            stop2.setAttribute('stop-opacity', '1');
            
            const stop3 = document.createElementNS(svgNS, 'stop');
            stop3.setAttribute('offset', '100%');
            stop3.setAttribute('stop-color', '#ff6b6b');
            stop3.setAttribute('stop-opacity', '0.6');
            
            timeGradient.appendChild(stop1);
            timeGradient.appendChild(stop2);
            timeGradient.appendChild(stop3);
            defs.appendChild(timeGradient);

            // Enhanced current time line with glow effect
            const nowHour = Number(new Date().toLocaleString('en-US', { hour: 'numeric', hour12: false, timeZone: tzET }));
            const xNow = x(nowHour);
            
            // Glow effect for current time line
            const vlineGlow = document.createElementNS(svgNS, 'line');
            vlineGlow.setAttribute('x1', xNow);
            vlineGlow.setAttribute('x2', xNow);
            vlineGlow.setAttribute('y1', '0');
            vlineGlow.setAttribute('y2', String(rect.height));
            vlineGlow.setAttribute('stroke', '#ff6b6b');
            vlineGlow.setAttribute('stroke-width', '6');
            vlineGlow.setAttribute('stroke-opacity', '0.3');
            vlineGlow.setAttribute('stroke-dasharray', '8,4');
            vlineGlow.setAttribute('stroke-linecap', 'round');
            svg.appendChild(vlineGlow);
            
            // Main current time line
            const vline = document.createElementNS(svgNS, 'line');
            vline.setAttribute('x1', xNow);
            vline.setAttribute('x2', xNow);
            vline.setAttribute('y1', '0');
            vline.setAttribute('y2', String(rect.height));
            vline.setAttribute('stroke', 'url(#timeLineGradient)');
            vline.setAttribute('stroke-width', '2.5');
            vline.setAttribute('stroke-dasharray', '8,4');
            vline.setAttribute('stroke-linecap', 'round');
            svg.appendChild(vline);

            // X-axis labels at fixed hours
            const labelHours = [5,8,11,14,17,20,23];
            labelHours.forEach(h => {
                const text = document.createElementNS(svgNS, 'text');
                text.setAttribute('x', x(h));
                text.setAttribute('y', String(rect.height - 6));
                text.setAttribute('fill', '#b0b0b0');
                text.setAttribute('font-size', '12');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = new Date(`1970-01-01T${String(h).padStart(2,'0')}:00:00`).toLocaleTimeString('en-US',{hour:'numeric',hour12:true});
                svg.appendChild(text);
            });
        }
        
        // Find current ET hour and nearest point index
        let currentTimeIndex = -1;
        let minTimeDiff = Infinity;
        const nowETHour = Number(new Date().toLocaleString('en-US', { hour: 'numeric', hour12: false, timeZone: tzET }));
        validData.forEach((point, index) => {
            const diff = Math.abs(hourET(point.time) - nowETHour);
            if (diff < minTimeDiff) {
                minTimeDiff = diff;
                currentTimeIndex = index;
            }
        });
        
        console.log(`üéØ Current time index: ${currentTimeIndex} (${Math.round(minTimeDiff / 1000 / 60)} minutes diff)`);
        
        // Create chart points and labels
        const plotArea = document.getElementById('plotArea');
        const xAxis = document.getElementById('xAxis');
        
        if (!plotArea || !xAxis) {
            console.error('‚ùå Chart elements not found');
            showChartError('Chart display elements not found');
            return;
        }
        
        // Clear existing content
        plotArea.innerHTML = '';
        xAxis.innerHTML = '';
        
        // Add data points and lines
        console.log('üé® Rendering chart with SVG...');
        renderWithSVG(validData, chartMin, chartMax);
        return; // Use the SVG rendering path exclusively
        
        // Error display function
        function showChartError(message) {
        const plotArea = document.getElementById('plotArea');
        if (plotArea) {
            plotArea.innerHTML = `
                <div style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    height: 100%;
                    color: var(--text-secondary);
                    font-style: italic;
                    text-align: center;
                    padding: 2rem;
                ">
                    <div>
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">üìä</div>
                        <div>${message}</div>
                        <div style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.7;">
                            Check the browser console for details
                        </div>
                    </div>
                </div>
            `;
        }
        
            // Also clear the Y-axis labels
            const yLabels = document.querySelectorAll('.y-label');
            yLabels.forEach(label => {
                label.textContent = '--¬∞F';
            });
        }
    }

    // Run on initial load or immediate execution if DOM is already ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initTempChart);
    } else {
        // If this template was injected via HTMX, DOMContentLoaded won't fire again
        initTempChart();
    }

    // Also run after HTMX swaps (when this fragment is injected)
    document.addEventListener('htmx:afterSwap', function(evt) {
        try {
            // If the swap affected our chart container or the results area, re-init
            const target = evt && evt.detail ? evt.detail.target : null;
            if (document.getElementById('plotArea') || (target && (target.id === 'weather-results' || target.querySelector && target.querySelector('#plotArea')))) {
                initTempChart();
            }
        } catch (e) {
            console.error('Error re-initializing chart after HTMX swap:', e);
        }
    });
    </script>
    
    <style>
    .temperature-graph-card {
        margin: 1.5rem 0;
    }
    
    .temperature-graph-card h2 {
        margin-bottom: 1rem;
        color: var(--text-primary);
        font-size: 1.5rem;
        font-weight: 600;
    }
    
    .simple-chart-container {
        background: var(--bg-primary);
        border-radius: 12px;
        padding: 1rem;
    }
    
    .chart-area {
        position: relative;
        height: 250px;
        margin-bottom: 1rem;
    }
    
    .y-axis {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 40px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-end;
        padding-right: 8px;
    }
    
    .y-label {
        font-size: 0.8rem;
        color: var(--text-secondary);
        line-height: 1;
    }
    
    .plot-area {
        position: absolute;
        left: 45px;
        top: 10px;
        right: 10px;
        bottom: 30px;
        border-left: 1px solid rgba(255, 255, 255, 0.2);
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .data-point {
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        transform: translate(-50%, 50%);
        cursor: pointer;
        z-index: 2;
    }
    
    .actual-temp-point {
        background-color: #43a047;
        border: 2px solid #43a047;
    }
    
    .feels-like-point {
        background-color: #1976d2;
        border: 2px solid #1976d2;
    }
    
    .current-time-point {
        background-color: #ff6b6b !important;
        border-color: #ff6b6b !important;
        width: 12px;
        height: 12px;
        box-shadow: 0 0 8px rgba(255, 107, 107, 0.6);
    }
    
    .temp-line {
        position: absolute;
        height: 2px;
        transform-origin: left center;
        z-index: 1;
    }
    
    .actual-temp-line {
        background-color: #43a047;
    }
    
    .feels-like-line {
        background-color: #1976d2;
    }
    
    .x-axis {
        position: absolute;
        left: 45px;
        bottom: 0;
        right: 10px;
        height: 25px;
        display: flex;
        align-items: center;
    }
    
    .time-label {
        position: absolute;
        font-size: 0.75rem;
        color: var(--text-secondary);
        transform: translateX(-50%);
        white-space: nowrap;
    }
    
    .current-time-label {
        color: #ff6b6b;
        font-weight: bold;
    }
    
    .chart-legend {
        display: flex;
        justify-content: center;
        gap: 1.5rem;
        margin-top: 1rem;
        flex-wrap: wrap;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
        color: var(--text-primary);
    }
    
    .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
    }
    
    .legend-color.actual-temp {
        background-color: #43a047;
    }
    
    .legend-color.feels-like-temp {
        background-color: #1976d2;
    }
    
    .legend-color.current-time {
        background-color: #ff6b6b;
    }
    
    @media (max-width: 600px) {
        .chart-legend {
            gap: 1rem;
        }
        
        .legend-item {
            font-size: 0.8rem;
        }
        
        .time-label {
            font-size: 0.7rem;
        }
    }
    </style>
</div>
{% endblock %}
